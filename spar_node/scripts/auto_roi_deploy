#!/usr/bin/env python3
# Shebang: run this file with whatever 'python3' points to on your system (ROS-friendly).

## Imports
# ------------------------------------------------------------------------------------------------------------
import sys
import os
from math import *

import rospy
# rospy = ROS 1's Python client library (allows this script to act as a ROS node,
#        access parameters, log to console, sleep, and register shutdown hooks).

import actionlib
# actionlib = ROS 1's Python library for creating and using *Action* interfaces.
#             Provides SimpleActionClient (used here) to send goals to an Action Server,
#             receive feedback during execution, and get the final result or status.
#             Handles the low-level goal/feedback/result topic communication automatically.

from actionlib_msgs.msg import GoalStatus
# The GoalStatus message contains:
#   - goal_id  : unique identifier for the goal
#   - status   : numeric code indicating the goal's state (see constants below)
#
# The constants are:
#   PENDING   (0) — Goal accepted, waiting to start.
#   ACTIVE    (1) — Goal is in progress.
#   PREEMPTED (2) — Goal was cancelled after it started, now finished. (Terminal)
#   SUCCEEDED (3) — Goal completed successfully. (Terminal)
#   ABORTED   (4) — Goal failed during execution. (Terminal)
#   REJECTED  (5) — Goal was never run because it was invalid/unattainable. (Terminal)
#   PREEMPTING(6) — Cancellation requested after start, but not finished yet.
#   RECALLING (7) — Cancellation requested before start, not confirmed yet.
#   RECALLED  (8) — Goal cancelled before start and confirmed. (Terminal)
#   LOST      (9) — Client detects goal is lost (should not be sent by server).
#
# These codes let you write logic like:
#     if result.status == GoalStatus.SUCCEEDED:
#         print("Reached the waypoint!")

# Import message types from the ROS geometry_msgs package:
# - Point: a simple 3D coordinate (x, y, z), used for positions in space
# - PoseStamped: a full pose message (position + orientation) with a header
#   that includes time and reference frame; commonly used for robot/drone poses
from geometry_msgs.msg import Point, PointStamped, PoseStamped

# For deploying payload
from std_msgs.msg import Bool

# Import the SPAR flight motion action interface:
# - FlightMotionAction = the *action wrapper* (bundles goal, result, and feedback types so actionlib can manage them as one action).
# - FlightMotionGoal   = the goal message you fill in with motion parameters (type, position, yaw, speeds, convergence) and send to the action server (Spar_Node).
from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

from std_msgs.msg import Float32
# so we can publish the waypoint progress

from tf.transformations import euler_from_quaternion
# So we can compute Yaw from quaternion

import yaml
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class autopilot():
	def __init__(self, waypoints, config):

		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			raise ValueError("Invalid waypoint list input!")

		self.LANDING_ARUCO_ID = config["landing_aruco_id"]
		self.ALTITUDE = config["altitude"]

		# Initialises variable, later modified with callback_pose
		self.current_yaw = 0.0

		# Internal counter to see what waypoint were are up to
		self.waypoint_counter = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Save the input waypoints
		self.waypoints = waypoints

		# Make some space to record down our current location
		self.current_location = Point()
		self.have_pose = False  # becomes True in callback_pose once we receive a pose

		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.25)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)

		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)

		# Loiter times (seconds)
		self.loiter_time  = rospy.get_param("~loiter_time", 5.0)   # how long to Loiter above ROI

		# Record dict of visited ROIs
		self.visited_rois = set()

		self.payloads_deployed = {"person": False, "bag": False}

		# Create an action client to talk to the flight controller
		# -----------------------------------------------------------------

		# Get the action topic name from a ROS parameter (~action_topic).
		# Default is 'spar/flight' if no parameter is set.
		action_ns = rospy.get_param("~action_topic", 'spar/flight')

		# Create a SimpleActionClient for the FlightMotionAction type.
		# This lets us send waypoints/goals to the flight server.
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)

		# Wait until the action server is online before continuing.
		# Prevents us from trying to send goals before the server is ready.
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")

			# Subscriptions first, so we already have pose during/after takeoff
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("/mavros/local_position/pose",
								 PoseStamped,
								 self.callback_pose)

			# Subscriber to catch "ROI" diversion commands
			# self.sub_roi = rospy.Subscriber("~roi", PointStamped, self.callback_inspect_roi)
			self.sub_roi_person = rospy.Subscriber(f"/marker_locations/id/person", PointStamped, self.callback_inspect_roi, callback_args=False)
			self.sub_roi_bag = rospy.Subscriber(f"/marker_locations/id/bag", PointStamped, self.callback_inspect_roi, callback_args=False)
			self.sub_landing_marker = None

			# Create a ROS publisher to send messages to the 'servo*/set' topic.
			self.pub_epipen = rospy.Publisher("/servo1/set", Bool, queue_size=10)
			self.pub_tracker = rospy.Publisher("/servo2/set", Bool, queue_size=10)

			# Take off to a configured height; block until complete
			self.send_takeoff_motion()

			# Send first waypoint after takeoff
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )

			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)

			# Publisher to output our waypoint progress (as a float: 0.0–1.0)
			self.pub_progress = rospy.Publisher("~waypoint_progress", Float32, queue_size=10)

			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.on_shutdown( lambda : self.shutdown() )

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):

		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False
		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False
		# Make sure waypoint is within mission zone
		x, y, z, yaw = wp
		if x > 3.8 or x < -3.8:
			rospy.logwarn("Waypoint x=%.2f outside [-3.8, 3.8]" % x)
			return False
		if y > 2.0 or y < -2.5:
			rospy.logwarn("Waypoint y=%.2f outside [-2.5, 2.0]" % y)
			return False
		if z > 4.0 or z < 0.5:
			rospy.logwarn("Waypoint z=%.2f outside [0, 0.5]" % z)
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True


	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		if self.sub_landing_marker is not None:
			self.sub_landing_marker.unregister()
		if self.sub_roi_person is not None:
			self.sub_roi_person.unregister()
		if self.sub_roi_bag is not None:
			self.sub_roi_bag.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Autopilot stopped")


	def callback_pose(self, msg_in: PoseStamped):
		# Position snapshot (for returns)
		self.current_location = msg_in.pose.position
		# Keep current yaw up to date
		self.current_yaw = self._quat_to_yaw(msg_in.pose.orientation)
		self.have_pose = True


	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in: PointStamped, landing: bool = False):

		# Check we haven't visited this roi already
		hdr = getattr(msg_in, "_connection_header", {}) or {}
		topic = hdr.get("topic")  # may be None in some contexts

		if topic in self.visited_rois:
			rospy.loginfo_throttle_identical(2, "already visited topic=%s", topic)
			return
	
		# Extract the "id" from the topic (last part of the path)
		roi_id = topic.split("/")[-1]  # will be "person" or "bag"
		
		rospy.loginfo(f"ROI diversion triggered for id: {roi_id}")

		# Record our current location so we can return to it later
		start_x = float(self.current_location.x)
		start_y = float(self.current_location.y)
		start_z = float(self.current_location.z)
		
		# XXX:	It would also be a good idea to capture "current yaw" from
		#		the pose to maintain that throughout a diversion
		
		current_yaw = self.current_yaw
		
		# Set the "diversion waypoint" (at yaw zero)
		# editing from msg_in.pose.position.z to start_z
		# descend to 0.8 for payload deployment
		dwp = [msg_in.point.x, msg_in.point.y, 0.8, current_yaw]
		
		if not self.check_waypoint(dwp):
			rospy.logwarn_throttle_identical(2, "Bad ROI waypoint, outside of safe flight zone!\nCancelling diversion...")
			return

		# If we’re already diverting, ignore further ROI requests
		if self.performing_roi:
			rospy.logwarn_throttle_identical(2, "ROI request ignored: diversion already in progress.")
			return

		# We need a current pose to be able to return safely
		if not self.have_pose:
			rospy.logwarn_throttle_identical(2, "No current pose yet; cannot divert to ROI.")
			return

		# Set our flag that we are performing the diversion and cancel active goal
		self.performing_roi = True
		rospy.loginfo("Starting diversion to ROI...")
		self.spar_client.cancel_goal()            
		
		# Set the "return waypoint" (at yaw zero)
		rwp = [start_x, start_y, start_z, current_yaw]

		# XXX: Could pause here for a moment with ( "rospy.sleep(...)" ) to make sure the UAV stops correctly

		rospy.sleep(rospy.Duration(0.5))

		self.send_wp(dwp)
		self.spar_client.wait_for_result()
		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			# Something went wrong, cancel out of guidance!
			rospy.signal_shutdown("cancelled")
			return

		rospy.loginfo("Reached diversion ROI!")
		self.visited_rois.add(topic)

		# Loiter above ROI
		if self.loiter_time > 0.0:
			rospy.loginfo("Hovering over ROI for %.1f s", self.loiter_time)
			rospy.sleep(rospy.Duration(self.loiter_time))

		# !!!: Change this to modify behaviour at ROIs
		if not landing: # deployment roi
			if roi_id == "person":
				rospy.loginfo("Hovering over person...")
				rospy.loginfo("Deploying epipen payload...")
				self.pub_epipen.publish(Bool(True))
				self.payloads_deployed["person"] = True
				rospy.loginfo("Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			elif roi_id == "bag":
				rospy.loginfo("Hovering over bag...")
				rospy.loginfo("Deploying tracker payload...")
				self.pub_tracker.publish(Bool(True))
				self.payloads_deployed["bag"] = True
				rospy.loginfo("Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			else:
				rospy.loginfo("Hovering over ROI...")
				rospy.sleep(rospy.Duration(self.loiter_time))

		# Land if landing flag true
		if landing:
			# Land at ROI
			rospy.loginfo("Setting down at ROI")
			try:
				self.send_land_motion()
				rospy.loginfo("ROI landing complete; shutting down.")
				rospy.signal_shutdown("complete")
			except e:
				rospy.signal_shutdown(f"roi_land_failed: {e}")
				self.performing_roi = False
				return

		rospy.loginfo("Returning to pre-diversion position...")
		self.send_wp(rwp)
		self.spar_client.wait_for_result()
		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			# Something went wrong, cancel out of guidance!
			rospy.signal_shutdown("cancelled")
			return

		# "waypoint_counter" represents the "next waypoint"
		# "waypoint_counter - 1" represents the "current waypoint"
		rospy.loginfo("Resuming flight plan from waypoint %i!" % (self.waypoint_counter - 1))
		self.send_wp(self.waypoints[self.waypoint_counter - 1])
		# Unset our flag that we are performing a diversion
		# to allow the waypoint timer to take back over
		self.performing_roi = False


	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):
		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			raise ValueError("Invalid waypoint input!")

		## Build the flight goal
		# -----------------------
		# Construct an empty goal message of type spar_msgs/FlightMotionGoal.
		goal = FlightMotionGoal()
		# Select motion mode: 'go to' a pose (as opposed to takeoff/land/velocity).
		goal.motion = FlightMotionGoal.MOTION_GOTO

		# Target position in SPAR's local frame.
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		# Target yaw (radians). Convention: typically yaw=0 aligns with +X axis of the local frame.
		goal.yaw = wp[3]

		# Commanded limits: vertical climb/descend speed, horizontal speed, and yaw rate.
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw

		# Tell SPAR to only declare success when we are within the acceptance thresholds below.
		goal.wait_for_convergence = True

		# Acceptance thresholds:
		# - position_radius (meters): how close to (x,y,z) we must be.
		# - yaw_range (radians): how close to target yaw we must be.
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())

	def send_takeoff_motion(self):
		"""
		Command a vertical takeoff using SPAR's FlightMotionAction.
		Blocks until the server reports success/failure.
		"""
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_TAKEOFF

		# Parameters (private to this node). Change names if you prefer.
		height = rospy.get_param("~height", 1.0)           # meters
		speed  = rospy.get_param("~speed",  0.3)           # m/s ascent speed

		goal.position.z = height
		goal.velocity_vertical = speed

		# Convergence rules (reuse your existing tolerances if you like)
		goal.wait_for_convergence = True
		goal.position_radius = rospy.get_param("~position_radius", 0.1)  # m
		goal.yaw_range       = rospy.get_param("~yaw_range",       0.1)  # rad

		rospy.loginfo("Takeoff: target z=%.2f m, vz=%.2f m/s", height, speed)
		self.spar_client.send_goal(goal)

		# Cancel safely if the node is stopped mid-takeoff
		rospy.on_shutdown(self.spar_client.cancel_goal)

		self.spar_client.wait_for_result()
		st = self.spar_client.get_state()

		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("Takeoff complete.")
		else:
			# Mirror your existing status handling
			rospy.logerr("Takeoff failed (state=%d). Aborting mission.", st)
			rospy.signal_shutdown("takeoff_failed")

	def send_land_motion(self, speed=None):
		"""
		Land using SPAR's FlightMotionAction (MOTION_LAND).
		Returns True on success, False otherwise.
		"""
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_LAND

		# Use ~land_speed if provided, else fall back to ~speed (or 0.2)
		if speed is None:
			speed = rospy.get_param("~land_speed", rospy.get_param("~speed", 0.2))
		goal.velocity_vertical = float(speed)  # SPAR ignores other velocities for land

		rospy.loginfo("Landing...")
		self.spar_client.send_goal(goal)
		rospy.on_shutdown(self.spar_client.cancel_goal)
		self.spar_client.wait_for_result()

		st = self.spar_client.get_state()
		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("Landing complete!")
			return True

		# Detailed feedback (optional)
		rospy.logerr("Landing failed (state=%d).", st)
		if st in (GoalStatus.PENDING, GoalStatus.ACTIVE):
			rospy.loginfo("Sent command to cancel current mission")
		elif st == GoalStatus.PREEMPTED:
			rospy.logwarn("The current mission was cancelled")
		elif st == GoalStatus.ABORTED:
			rospy.logwarn("The current mission was aborted")
		elif st == GoalStatus.RECALLED:
			rospy.logerr("Error: The current mission was recalled")
		elif st == GoalStatus.REJECTED:
			rospy.logerr("Error: The current mission was rejected")
		else:
			rospy.logerr("Error: Unknown goal status")
		return False

	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or diversion mode here.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo("Reached waypoint %i!" % (self.waypoint_counter))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.waypoint_counter < (len(self.waypoints)):
					self.send_wp(self.waypoints[self.waypoint_counter])

					# Calculate fraction of mission complete (waypoints done / total)
					progress = float(self.waypoint_counter) / float(len(self.waypoints))
					self.pub_progress.publish(progress)
					rospy.loginfo("Mission progress: %.0f%%" % (progress * 100.0))

					# Increment our waypoint counter
					self.waypoint_counter += 1
				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission
					rospy.loginfo_throttle_identical(5, "Search complete! Checking payloads deployed...")

					if self.payloads_deployed["person"] == False:
						rospy.loginfo("Hovering over person...")
						rospy.loginfo("Deploying epipen payload...")
						self.pub_epipen.publish(Bool(True))
						self.payloads_deployed["person"] = True
						rospy.loginfo("Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))
					
					if self.payloads_deployed["bag"] == False:
						rospy.loginfo("Hovering over bag...")
						rospy.loginfo("Deploying tracker payload...")
						self.pub_tracker.publish(Bool(True))
						self.payloads_deployed["bag"] = True
						rospy.loginfo("Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))

					rospy.loginfo_throttle_identical(5, "Mission complete! Landing...")
					self.sub_landing_marker = rospy.Subscriber(f"/marker_locations/id/{self.LANDING_ARUCO_ID}", PointStamped, self.callback_inspect_roi, callback_args=True)
					# self.send_land_motion()
					# rospy.signal_shutdown("complete")
			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled!")
				rospy.signal_shutdown("cancelled")

	def _quat_to_yaw(self, q):
		"""Return yaw (rad) from geometry_msgs/Quaternion."""
		_, _, yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])
		return yaw


def main(args):
	# Initialise ROS
	rospy.init_node('autopilot')

	# Load config
	print(os.getcwd())
	with open(f"{os.getcwd()}/catkin_ws/config.yaml", "r") as f:
		config = yaml.safe_load(f)

	# Set our altitude from config
	ALTITUDE = config["altitude"]

	# List of waypoints
	# [X, Y, Z, Yaw]
	wps = [
			[-1.0,  -1.0,  1.0, 	 0.0],
			[-1.0,  -1.0,  ALTITUDE, 0.0],
			[-3.75, -2.45, ALTITUDE, 0.0],
			[-3.75, -2.45, ALTITUDE, 0.0],
			[-3.75,  0.0,  ALTITUDE, 0.0],
			[-3.75,  1.95, ALTITUDE, 0.0],
			[-1.51,  1.95, ALTITUDE, 0.0],
			[-1.51,  0.0,  ALTITUDE, 0.0],
			[-1.51, -2.45, ALTITUDE, 0.0],
			[ 0.79, -2.45, ALTITUDE, 0.0],
			[ 0.79,  0.0,  ALTITUDE, 0.0],
			[ 0.79,  1.95, ALTITUDE, 0.0],
			[ 3.08,  1.95, ALTITUDE, 0.0],
			[ 3.08,  0.0,  ALTITUDE, 0.0],
			[ 3.08, -2.45, ALTITUDE, 0.0],
			[ 3.75, -2.45, ALTITUDE, 0.0],
			[ 3.75,  0.0,  ALTITUDE, 0.0],
			[ 3.75,  1.95, ALTITUDE, 0.0],
		]

	# Create our Autopilot class option
	pilot = autopilot(wps, config)

	# rospy.spin() keeps the program running once setup is done.
	# Without it, the script would exit immediately after starting.
	# It lets ROS continuously process incoming messages and call
	# subscriber callbacks (e.g. for pose updates or ROI triggers).
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
