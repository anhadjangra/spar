#!/usr/bin/env python3
# Shebang: run this file with whatever 'python3' points to on your system (ROS-friendly).

## Imports
# ------------------------------------------------------------------------------------------------------------
import sys
import os
from math import *

import rospy
# rospy = ROS 1's Python client library (allows this script to act as a ROS node,
#        access parameters, log to console, sleep, and register shutdown hooks).

import actionlib
# actionlib = ROS 1's Python library for creating and using *Action* interfaces.
#             Provides SimpleActionClient (used here) to send goals to an Action Server,
#             receive feedback during execution, and get the final result or status.
#             Handles the low-level goal/feedback/result topic communication automatically.

from actionlib_msgs.msg import GoalStatus
# The GoalStatus message contains:
#   - goal_id  : unique identifier for the goal
#   - status   : numeric code indicating the goal's state (see constants below)
#
# The constants are:
#   PENDING   (0) — Goal accepted, waiting to start.
#   ACTIVE    (1) — Goal is in progress.
#   PREEMPTED (2) — Goal was cancelled after it started, now finished. (Terminal)
#   SUCCEEDED (3) — Goal completed successfully. (Terminal)
#   ABORTED   (4) — Goal failed during execution. (Terminal)
#   REJECTED  (5) — Goal was never run because it was invalid/unattainable. (Terminal)
#   PREEMPTING(6) — Cancellation requested after start, but not finished yet.
#   RECALLING (7) — Cancellation requested before start, not confirmed yet.
#   RECALLED  (8) — Goal cancelled before start and confirmed. (Terminal)
#   LOST      (9) — Client detects goal is lost (should not be sent by server).
#
# These codes let you write logic like:
#     if result.status == GoalStatus.SUCCEEDED:
#         print("Reached the waypoint!")

# Import message types from the ROS geometry_msgs package:
# - Point: a simple 3D coordinate (x, y, z), used for positions in space
# - PoseStamped: a full pose message (position + orientation) with a header
#   that includes time and reference frame; commonly used for robot/drone poses
from geometry_msgs.msg import Point, PointStamped, PoseStamped

# For deploying payload
from std_msgs.msg import Bool

# Import the SPAR flight motion action interface:
# - FlightMotionAction = the *action wrapper* (bundles goal, result, and feedback types so actionlib can manage them as one action).
# - FlightMotionGoal   = the goal message you fill in with motion parameters (type, position, yaw, speeds, convergence) and send to the action server (Spar_Node).
from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

from std_msgs.msg import Float32
# so we can publish the waypoint progress

from tf.transformations import euler_from_quaternion
# So we can compute Yaw from quaternion

# A* Path Planning
from breadcrumb.srv import RequestPath
from breadcrumb.srv import RequestPathRequest
from nav_msgs.msg import Path
from nav_msgs.msg import OccupancyGrid


import yaml
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class autopilot():
	def __init__(self, waypoints, config):
		# --- Mission bounds
		self.X_MIN, self.X_MAX = -3.8,  3.8
		self.Y_MIN, self.Y_MAX = -2.5,  2.0
		self.Z_MIN, self.Z_MAX =  0.5,  4.0

		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			raise ValueError("Invalid waypoint list input!")

		self.LANDING_ARUCO_ID = config["landing_aruco_id"]
		self.ALTITUDE = config["altitude"]

		# Initialises variable, later modified with callback_pose
		self.current_yaw = 0.0

		# Internal counter to see what waypoint were are up to
		self.waypoint_counter = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False

		# Save the input waypoints
		self.waypoints = waypoints

		# Display the full path
		self.display_path(waypoints,"/nav/fullPath")

		# Wait to connect with Breadcrumb
		# Code will error if you try to connect to a service
		# that does not exist
		rospy.wait_for_service('/breadcrumb/request_path')
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path', RequestPath)

		# Initialisation breadcrumb waypoints
		self.breadcrumbWPSnextIndex = 0
		self.breadcrumbMode = False
		self.breadcrumbWPS = []

		# Make some space to record down our current location
		self.current_location = Point()
		self.have_pose = False  # becomes True in callback_pose once we receive a pose

		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.25)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)

		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)

		# Loiter times (seconds)
		self.loiter_time  = rospy.get_param("~loiter_time", 5.0)   # how long to Loiter above ROI

		# Record dict of visited ROIs
		self.visited_rois = set()

		self.payloads_deployed = {"person": False, "bag": False}

		# Create an action client to talk to the flight controller
		# -----------------------------------------------------------------

		# Get the action topic name from a ROS parameter (~action_topic).
		# Default is 'spar/flight' if no parameter is set.
		action_ns = rospy.get_param("~action_topic", 'spar/flight')

		# Create a SimpleActionClient for the FlightMotionAction type.
		# This lets us send waypoints/goals to the flight server.
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)

		# Wait until the action server is online before continuing.
		# Prevents us from trying to send goals before the server is ready.
		rospy.loginfo("Waiting for spar...")
		self.spar_client.wait_for_server()

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("Starting waypoint mission")

			# Subscriptions first, so we already have pose during/after takeoff
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("/mavros/local_position/pose",
								 PoseStamped,
								 self.callback_pose)

			# --- Occupancy Grid (for snapping waypoints out of obstacles)
			self.grid = None
			self.grid_thresh = rospy.get_param("~obstacle_threshold",
											rospy.get_param("/breadcrumb/obstacle_threshold", 50))
			self.grid_inflation = rospy.get_param("~snap_inflation_margin", 0.0)  # meters; optional
			self.sub_grid = rospy.Subscriber("/grid", OccupancyGrid, self._cb_grid, queue_size=1)

			# Subscriber to catch "ROI" diversion commands
			# self.sub_roi = rospy.Subscriber("~roi", PointStamped, self.callback_inspect_roi)
			self.sub_roi_person = rospy.Subscriber(f"/marker_locations/id/person", PointStamped, self.callback_inspect_roi, callback_args=False)
			self.sub_roi_bag = rospy.Subscriber(f"/marker_locations/id/bag", PointStamped, self.callback_inspect_roi, callback_args=False)
			self.sub_landing_marker = None

			# Create a ROS publisher to send messages to the '/payload/{PAYLOAD_TYPE}/set' topic.
			self.pub_epipen = rospy.Publisher("/payload/epipen/set", Bool, queue_size=10)
			self.pub_tracker = rospy.Publisher("/payload/tracker/set", Bool, queue_size=10)

			# Take off to a configured height; block until complete
			self.send_takeoff_motion()

			# Send first waypoint after takeoff
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )

			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)

			# Publisher to output our waypoint progress (as a float: 0.0–1.0)
			self.pub_progress = rospy.Publisher("~waypoint_progress", Float32, queue_size=10)

			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.on_shutdown( lambda : self.shutdown() )

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):

		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("Waypoint is not a list of coordinates")
			return False
		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False
		# Make sure waypoint is within mission zone
		x, y, z, yaw = wp
		if x > self.X_MAX or x < self.X_MIN:
			rospy.logwarn("Waypoint x=%.2f outside [-3.8, 3.8]" % x)
			return False
		if y > self.Y_MAX or y < self.Y_MIN:
			rospy.logwarn("Waypoint y=%.2f outside [-2.5, 2.0]" % y)
			return False
		if z > self.Z_MAX or z < self.Z_MIN:
			rospy.logwarn("Waypoint z=%.2f outside [0, 0.5]" % z)
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True


	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		if self.sub_landing_marker is not None:
			self.sub_landing_marker.unregister()
		if self.sub_roi_person is not None:
			self.sub_roi_person.unregister()
		if self.sub_roi_bag is not None:
			self.sub_roi_bag.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("Autopilot stopped")


	def callback_pose(self, msg_in: PoseStamped):
		# Position snapshot (for returns)
		self.current_location = msg_in.pose.position
		# Keep current yaw up to date
		self.current_yaw = self._quat_to_yaw(msg_in.pose.orientation)
		self.have_pose = True


	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in: PointStamped, landing: bool = False):
		# Check we haven't visited this roi already
		hdr = getattr(msg_in, "_connection_header", {}) or {}
		topic = hdr.get("topic")  # may be None in some contexts

		# Extract the "id" from the topic (last part of the path)
		roi_id = topic.split("/")[-1]  # will be "person" or "bag"
		rospy.loginfo(f"ROI diversion triggered for id: {roi_id}")

		# Record our current location so we can return to it later
		start_x = float(self.current_location.x)
		start_y = float(self.current_location.y)
		start_z = float(self.current_location.z)
		# XXX:	It would also be a good idea to capture "current yaw" from
		#		the pose to maintain that throughout a diversion

		current_yaw = self.current_yaw

		# Set the "diversion waypoint" (at yaw zero)
		# editing from msg_in.pose.position.z to start_z
		# descend to 0.8 for payload deployment

		raw_dwp = [msg_in.point.x, msg_in.point.y, 0.8, current_yaw]
		dwp = self.snap_wp_in_mission(raw_dwp)
		if dwp[0] != raw_dwp[0] or dwp[1] != raw_dwp[1]:
			rospy.logwarn("ROI target snapped (%.2f, %.2f) -> (%.2f, %.2f)",
						raw_dwp[0], raw_dwp[1], dwp[0], dwp[1])

		if not self.check_waypoint(dwp):
			rospy.logwarn_throttle_identical(2, "Bad ROI waypoint, outside of safe flight zone!\nCancelling diversion...")
			return

		# If we’re already diverting, ignore further ROI requests
		if self.performing_roi:
			rospy.logwarn_throttle_identical(2, "ROI request ignored: diversion already in progress.")
			return

		# We need a current pose to be able to return safely
		if not self.have_pose:
			rospy.logwarn_throttle_identical(2, "No current pose yet; cannot divert to ROI.")
			return

		if topic in self.visited_rois:
			rospy.loginfo_throttle_identical(2, "already visited topic=%s", topic)
			return

		# Set our flag that we are performing the diversion and cancel active goal
		self.performing_roi = True
		rospy.loginfo("Starting diversion to ROI...")
		self.spar_client.cancel_goal()

		# Set the "return waypoint" (at yaw zero)
		rwp = [start_x, start_y, start_z, current_yaw]

		# XXX: Could pause here for a moment with ( "rospy.sleep(...)" ) to make sure the UAV stops correctly

		rospy.sleep(rospy.Duration(0.5))

		self.send_wp(dwp)
		self.spar_client.wait_for_result()
		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			# Something went wrong, cancel out of guidance!
			rospy.signal_shutdown("cancelled")
			return

		rospy.loginfo("Reached diversion ROI!")
		self.visited_rois.add(topic)

		# Loiter above ROI
		if self.loiter_time > 0.0:
			rospy.loginfo("Hovering over ROI for %.1f s", self.loiter_time)
			rospy.sleep(rospy.Duration(self.loiter_time))

		# !!!: Change this to modify behaviour at ROIs
		if not landing: # deployment roi
			if roi_id == "person":
				rospy.loginfo("Hovering over person...")
				rospy.loginfo("Deploying epipen payload...")
				self.pub_epipen.publish(Bool(True))
				self.payloads_deployed["person"] = True
				rospy.loginfo("Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			elif roi_id == "bag":
				rospy.loginfo("Hovering over bag...")
				rospy.loginfo("Deploying tracker payload...")
				self.pub_tracker.publish(Bool(True))
				self.payloads_deployed["bag"] = True
				rospy.loginfo("Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			else:
				rospy.loginfo("Hovering over ROI...")
				rospy.sleep(rospy.Duration(self.loiter_time))

		# Land if landing flag true
		if landing:
			# Land at ROI
			rospy.loginfo("Setting down at ROI")
			try:
				self.send_land_motion()
				rospy.loginfo("ROI landing complete; shutting down.")
				rospy.signal_shutdown("complete")
			except e:
				rospy.signal_shutdown(f"roi_land_failed: {e}")
				self.performing_roi = False
				return

		rospy.loginfo("Returning to pre-diversion position...")
		self.send_wp(rwp)
		self.spar_client.wait_for_result()
		if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
			# Something went wrong, cancel out of guidance!
			rospy.signal_shutdown("cancelled")
			return

		# "waypoint_counter" represents the "next waypoint"
		# "waypoint_counter - 1" represents the "current waypoint"
		rospy.loginfo("Resuming flight plan from waypoint %i!" % (self.waypoint_counter - 1))
		self.send_wp(self.waypoints[self.waypoint_counter - 1])
		# Unset our flag that we are performing a diversion
		# to allow the waypoint timer to take back over
		self.performing_roi = False


	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):
		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			raise ValueError("Invalid waypoint input!")

		## Build the flight goal
		# -----------------------
		# Construct an empty goal message of type spar_msgs/FlightMotionGoal.
		goal = FlightMotionGoal()
		# Select motion mode: 'go to' a pose (as opposed to takeoff/land/velocity).
		goal.motion = FlightMotionGoal.MOTION_GOTO

		# Target position in SPAR's local frame.
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		# Target yaw (radians). Convention: typically yaw=0 aligns with +X axis of the local frame.
		goal.yaw = wp[3]

		# Commanded limits: vertical climb/descend speed, horizontal speed, and yaw rate.
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw

		# Tell SPAR to only declare success when we are within the acceptance thresholds below.
		goal.wait_for_convergence = True

		# Acceptance thresholds:
		# - position_radius (meters): how close to (x,y,z) we must be.
		# - yaw_range (radians): how close to target yaw we must be.
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())

	def send_takeoff_motion(self):
		"""
		Command a vertical takeoff using SPAR's FlightMotionAction.
		Blocks until the server reports success/failure.
		"""
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_TAKEOFF

		# Parameters (private to this node). Change names if you prefer.
		height = rospy.get_param("~height", 1.0)           # meters
		speed  = rospy.get_param("~speed",  0.3)           # m/s ascent speed

		goal.position.z = height
		goal.velocity_vertical = speed

		# Convergence rules (reuse your existing tolerances if you like)
		goal.wait_for_convergence = True
		goal.position_radius = rospy.get_param("~position_radius", 0.1)  # m
		goal.yaw_range       = rospy.get_param("~yaw_range",       0.1)  # rad

		rospy.loginfo("Takeoff: target z=%.2f m, vz=%.2f m/s", height, speed)
		self.spar_client.send_goal(goal)

		# Cancel safely if the node is stopped mid-takeoff
		rospy.on_shutdown(self.spar_client.cancel_goal)

		self.spar_client.wait_for_result()
		st = self.spar_client.get_state()

		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("Takeoff complete.")
		else:
			# Mirror your existing status handling
			rospy.logerr("Takeoff failed (state=%d). Aborting mission.", st)
			rospy.signal_shutdown("takeoff_failed")

	def send_land_motion(self, speed=None):
		"""
		Land using SPAR's FlightMotionAction (MOTION_LAND).
		Returns True on success, False otherwise.
		"""
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_LAND

		# Use ~land_speed if provided, else fall back to ~speed (or 0.2)
		if speed is None:
			speed = rospy.get_param("~land_speed", rospy.get_param("~speed", 0.2))
		goal.velocity_vertical = float(speed)  # SPAR ignores other velocities for land

		rospy.loginfo("Landing...")
		self.spar_client.send_goal(goal)
		rospy.on_shutdown(self.spar_client.cancel_goal)
		self.spar_client.wait_for_result()

		st = self.spar_client.get_state()
		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("Landing complete!")
			return True

		# Detailed feedback (optional)
		rospy.logerr("Landing failed (state=%d).", st)
		if st in (GoalStatus.PENDING, GoalStatus.ACTIVE):
			rospy.loginfo("Sent command to cancel current mission")
		elif st == GoalStatus.PREEMPTED:
			rospy.logwarn("The current mission was cancelled")
		elif st == GoalStatus.ABORTED:
			rospy.logwarn("The current mission was aborted")
		elif st == GoalStatus.RECALLED:
			rospy.logerr("Error: The current mission was recalled")
		elif st == GoalStatus.REJECTED:
			rospy.logerr("Error: The current mission was rejected")
		else:
			rospy.logerr("Error: Unknown goal status")
		return False

	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or diversion mode here.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo_throttle_identical(5, "Reached waypoint %i!" % (self.waypoint_counter))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.waypoint_counter < (len(self.waypoints)):

					if not self.breadcrumbMode:

						sx, sy, sz = self.waypoints[self.waypoint_counter - 1][0:3]
						ex, ey, ez = self.waypoints[self.waypoint_counter][0:3]

						# Snap both endpoints; keep original z (already in mission plan), clamped by helper.
						s_start = self.snap_wp_in_mission([sx, sy, sz, 0.0])
						s_end   = self.snap_wp_in_mission([ex, ey, ez, 0.0])

						if (s_start[0], s_start[1]) != (sx, sy):
							rospy.logwarn("Segment start snapped (%.2f, %.2f) -> (%.2f, %.2f)", sx, sy, s_start[0], s_start[1])
						if (s_end[0], s_end[1]) != (ex, ey):
							rospy.logwarn("Segment end snapped (%.2f, %.2f) -> (%.2f, %.2f)", ex, ey, s_end[0], s_end[1])

						req = RequestPathRequest()
						req.start.x, req.start.y, req.start.z = s_start[0], s_start[1], s_start[2]
						req.end.x,   req.end.y,   req.end.z   = s_end[0],   s_end[1],   s_end[2]
						
						res = self.srvc_bc(req)
						
						# Breadcrumb will return a vector of poses if a solution was found
						# If no solution was found (i.e. no solution, or request bad # start/end), then breadcrumb returns and empty vector
						# # XXX: You could also use res.path_sparse (see breadcrumb docs)
						breadcrumbWPS = []
						
						if len(res.path.poses) > 0:
							# Print the path to the screen
							rospy.loginfo("Segment {} to {}:".format(self.waypoint_counter - 1,self.waypoint_counter))
							rospy.loginfo("[%0.2f;%0.2f;%0.2f] => [%0.2f;%0.2f;%0.2f]", req.start.x,req.start.y,req.start.z, req.end.x,req.end.y,req.end.z)
							
							# Loop through the solution returned from breadcrumb
							for i in range(len(res.path.poses)):
								rospy.loginfo(" [%0.2f;%0.2f;%0.2f]", res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z)
								breadcrumbWPS.append([res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z, 0.0])
								
							# Display the path
							# print(breadcrumbWPS)
							self.breadcrumbWPS = breadcrumbWPS
							self.display_path(breadcrumbWPS,"/nav/pathBreadcrumb")
							self.breadcrumbMode = True
							self.breadcrumbWPSnextIndex = 0
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							self.breadcrumbWPSnextIndex +=1
						else:
							rospy.logerr_throttle_identical(5, "breadcrumb solution not found, falling back to original path")
							self.send_wp(self.waypoints[self.waypoint_counter])
							self.waypoint_counter += 1

					else:
						if self.breadcrumbWPSnextIndex < (len(self.breadcrumbWPS)):
							# We got here a breadcrumb path, we should exuted down here:
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							
							# Increment our waypoint counte
							self.breadcrumbWPSnextIndex +=1
						else:
							# Calculate fraction of mission complete (waypoints done / total)
							progress = float(self.waypoint_counter) / float(len(self.waypoints))
							self.pub_progress.publish(progress)
							rospy.loginfo("Mission progress: %.0f%%" % (progress * 100.0))
							
							# If we finish with the breadcrumb waypoints we increase normal waypoints
							self.waypoint_counter += 1
							self.breadcrumbMode = False

				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission
					rospy.loginfo_throttle_identical(5, "Search complete! Checking payloads deployed...")

					if self.payloads_deployed["person"] == False:
						rospy.loginfo("Deploying epipen payload...")
						self.pub_epipen.publish(Bool(True))
						self.payloads_deployed["person"] = True
						rospy.loginfo("Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))

					if self.payloads_deployed["bag"] == False:
						rospy.loginfo("Deploying tracker payload...")
						self.pub_tracker.publish(Bool(True))
						self.payloads_deployed["bag"] = True
						rospy.loginfo("Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))

					rospy.loginfo_throttle_identical(5, "Mission complete! Landing...")
					self.sub_landing_marker = rospy.Subscriber(f"/marker_locations/id/{self.LANDING_ARUCO_ID}", PointStamped, self.callback_inspect_roi, callback_args=True)
					# self.send_land_motion()
					# rospy.signal_shutdown("complete")
			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				rospy.loginfo("Mission cancelled!")
				rospy.signal_shutdown("cancelled")
	def _clamp(self, v, vmin, vmax):
		return max(vmin, min(v, vmax))

	def _in_xy_bounds(self, x, y):
		return (self.X_MIN <= x <= self.X_MAX) and (self.Y_MIN <= y <= self.Y_MAX)

	def _cb_grid(self, msg):
		self.grid = msg

	def _world_to_cell(self, x, y):
		if self.grid is None:
			return None
		res = self.grid.info.resolution
		org = self.grid.info.origin.position
		ix = int((x - org.x) / res)
		iy = int((y - org.y) / res)
		if ix < 0 or iy < 0 or ix >= self.grid.info.width or iy >= self.grid.info.height:
			return None
		return ix, iy

	def _cell_value(self, ix, iy):
		if self.grid is None: 
			return 100
		idx = iy * self.grid.info.width + ix
		data = self.grid.data
		if idx < 0 or idx >= len(data):
			return 100
		v = data[idx]
		return 100 if v < 0 else v

	def _is_free(self, x, y):
		if not self._in_xy_bounds(x, y):
			return False
		c = self._world_to_cell(x, y)
		if c is None:
			return False
		ix, iy = c
		return self._cell_value(ix, iy) < self.grid_thresh

	def _snap_to_free_bounded(self, x, y, max_radius=1.5, angular_samples=24):
		"""
		Snap (x,y) to nearest free cell respecting mission bounds.
		If already free, returns unchanged. If no free cell found within radius,
		returns (x,y) clamped to mission box (still may be occupied).
		"""
		# First clamp to mission bounds so we don't search outside
		x = self._clamp(x, self.X_MIN, self.X_MAX)
		y = self._clamp(y, self.Y_MIN, self.Y_MAX)

		if self._is_free(x, y):
			return x, y

		if self.grid is None:
			# No grid yet – at least return bounded coords
			return x, y

		res = self.grid.info.resolution
		r = res
		while r <= max_radius:
			for k in range(angular_samples):
				th = (2.0 * pi * k) / float(angular_samples)
				xt = self._clamp(x + r * cos(th), self.X_MIN, self.X_MAX)
				yt = self._clamp(y + r * sin(th), self.Y_MIN, self.Y_MAX)
				if self._is_free(xt, yt):
					return xt, yt
			r += res

		# Nothing found: fall back to bounded original
		return x, y

	def snap_wp_in_mission(self, wp, max_radius=1.5):
		"""
		Given [x,y,z,yaw], snap x,y out of obstacles & clamp z so the result
		*passes check_waypoint()*.
		"""
		x, y, z, yaw = wp
		# snap x,y to free within bounds
		sx, sy = self._snap_to_free_bounded(x, y, max_radius=max_radius)

		# clamp z strictly to mission vertical bounds
		sz = self._clamp(z, self.Z_MIN, self.Z_MAX)

		snapped = [sx, sy, sz, yaw]

		# As a safety net: if something still fails (e.g., grid unknown),
		# try shrinking the radius a bit to find any valid point.
		if not self.check_waypoint(snapped):
			rr = max_radius
			while rr > 0.0:
				sx, sy = self._snap_to_free_bounded(x, y, max_radius=rr)
				snapped = [sx, sy, sz, yaw]
				if self.check_waypoint(snapped):
					break
				rr -= 0.25
		return snapped

	# Display a path
	def display_path(self, wps, name):
		rospy.loginfo("Displaying path...")
		pub_path = rospy.Publisher(name, Path, queue_size=10, latch=True)
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()
	
		for wp in wps:
			pose = PoseStamped()
			pose.pose.position.x = wp[0]
			pose.pose.position.y = wp[1]
			pose.pose.position.z = wp[2]
	
			pose.pose.orientation.w = 1.0
			pose.pose.orientation.x = 0.0
			pose.pose.orientation.y = 0.0
			pose.pose.orientation.z = 0.0
	
			msg.poses.append(pose)
		rospy.loginfo("Publishing path...")
		pub_path.publish(msg)

	def _quat_to_yaw(self, q):
		"""Return yaw (rad) from geometry_msgs/Quaternion."""
		_, _, yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])
		return yaw


def main(args):
	# Initialise ROS
	rospy.init_node('autopilot')

	# Load config
	print(os.getcwd())
	with open(f"{os.getcwd()}/catkin_ws/config.yaml", "r") as f:
		config = yaml.safe_load(f)

	# Set our altitude from config
	ALTITUDE = config["altitude"]

	# List of waypoints
	# [X, Y, Z, Yaw]
	wps = [
			[-1.00, -1.00, 1.00, 0.00],
			[-1.00, -1.00, ALTITUDE, 0.00],
			[-3.70, -2.40, ALTITUDE, 0.00],
			[-3.70, -0.25, ALTITUDE, 0.00],
			[-3.70,  1.90, ALTITUDE, 0.00],
			[-1.56,  1.90, ALTITUDE, 0.00],
			[-1.56, -0.25, ALTITUDE, 0.00],
			[-1.56, -2.40, ALTITUDE, 0.00],
			[ 0.58, -2.40, ALTITUDE, 0.00],
			[ 0.58, -0.25, ALTITUDE, 0.00],
			[ 0.58,  1.90, ALTITUDE, 0.00],
			[ 2.72,  1.90, ALTITUDE, 0.00],
			[ 2.72, -0.25, ALTITUDE, 0.00],
			[ 2.72, -2.40, ALTITUDE, 0.00],
			[ 3.70, -2.40, ALTITUDE, 0.00],
			[ 3.70, -0.25, ALTITUDE, 0.00],
			[ 3.70,  1.90, ALTITUDE, 0.00]
		]

	# Create our Autopilot class option
	pilot = autopilot(wps, config)

	# rospy.spin() keeps the program running once setup is done.
	# Without it, the script would exit immediately after starting.
	# It lets ROS continuously process incoming messages and call
	# subscriber callbacks (e.g. for pose updates or ROI triggers).
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
