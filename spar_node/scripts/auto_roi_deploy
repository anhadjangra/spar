#!/usr/bin/env python3
# Shebang: run this file with whatever 'python3' points to on your system (ROS-friendly).

## Imports
# ------------------------------------------------------------------------------------------------------------
import sys
import os
from math import *
import json
import numpy as np
import datetime

import rospy
# rospy = ROS 1's Python client library (allows this script to act as a ROS node,
#        access parameters, log to console, sleep, and register shutdown hooks).

import actionlib
# actionlib = ROS 1's Python library for creating and using *Action* interfaces.
#             Provides SimpleActionClient (used here) to send goals to an Action Server,
#             receive feedback during execution, and get the final result or status.
#             Handles the low-level goal/feedback/result topic communication automatically.

from actionlib_msgs.msg import GoalStatus
# The GoalStatus message contains:
#   - goal_id  : unique identifier for the goal
#   - status   : numeric code indicating the goal's state (see constants below)
#
# The constants are:
#   PENDING   (0) — Goal accepted, waiting to start.
#   ACTIVE    (1) — Goal is in progress.
#   PREEMPTED (2) — Goal was cancelled after it started, now finished. (Terminal)
#   SUCCEEDED (3) — Goal completed successfully. (Terminal)
#   ABORTED   (4) — Goal failed during execution. (Terminal)
#   REJECTED  (5) — Goal was never run because it was invalid/unattainable. (Terminal)
#   PREEMPTING(6) — Cancellation requested after start, but not finished yet.
#   RECALLING (7) — Cancellation requested before start, not confirmed yet.
#   RECALLED  (8) — Goal cancelled before start and confirmed. (Terminal)
#   LOST      (9) — Client detects goal is lost (should not be sent by server).
#
# These codes let you write logic like:
#     if result.status == GoalStatus.SUCCEEDED:
#         print("Reached the waypoint!")

# Import message types from the ROS geometry_msgs package:
# - Point: a simple 3D coordinate (x, y, z), used for positions in space
# - PoseStamped: a full pose message (position + orientation) with a header
#   that includes time and reference frame; commonly used for robot/drone poses
from geometry_msgs.msg import Point, PointStamped, PoseStamped

# For deploying payload
from std_msgs.msg import Bool, String, Float32, Float32MultiArray

# Import the SPAR flight motion action interface:
# - FlightMotionAction = the *action wrapper* (bundles goal, result, and feedback types so actionlib can manage them as one action).
# - FlightMotionGoal   = the goal message you fill in with motion parameters (type, position, yaw, speeds, convergence) and send to the action server (Spar_Node).
from spar_msgs.msg import FlightMotionAction, FlightMotionGoal

# so we can publish the waypoint progress

from tf.transformations import euler_from_quaternion
# So we can compute Yaw from quaternion

# A* Path Planning
from breadcrumb.srv import RequestPath, RequestPathRequest
from nav_msgs.msg import Path, OccupancyGrid

# For battery monitoring
from sensor_msgs.msg import BatteryState

import yaml
#----------------------------------------------------------------------------------------------------------------------------------------------------------------

# --- Mission bounds
X_MIN, X_MAX = -4.0,  4.0
Y_MIN, Y_MAX = -3.2,  2.0
Z_MIN, Z_MAX =  0.5,  4.0

# This is getting a bit more complicated now, so we'll put our information in
# a class to keep track of all of our variables. This is not so much different
# to the previous methods, other than the fact that the class will operate
# within itself.
# i.e. it will have it's own publishers, subscribers, etc., that
# will call it's own functions as callbacks, etc.
class autopilot():
	def __init__(self, waypoints, config, pub_mission_status):
		# Make sure we have a valid waypoint list
		if not self.check_waypoints(waypoints):
			raise ValueError("Invalid waypoint list input!")

		self.pub_mission_status = pub_mission_status
		self.pub_mission_status.publish("INITIALISING")

		self.LANDING_ARUCO_ID = config["landing_aruco_id"]
		self.ALTITUDE = config["altitude"]

		# Initialises variable, later modified with callback_pose
		self.current_yaw = 0.0

		# Internal counter to see what waypoint were are up to
		self.waypoint_counter = 0

		# Set a flag to indicate that we are doing a specific inspection
		# and that we are not following our waypoint list
		# This will stop our "waypoint is reached" callback from firing
		# during the roi diversion and taking over our flight!
		self.performing_roi = False
		self.performing_emergency = False
		self.landed = False

		# Save the input waypoints
		self.waypoints = waypoints

		# Display the full path
		self.display_path(waypoints,"/nav/fullPath")

		# Wait to connect with Breadcrumb
		# Code will error if you try to connect to a service
		# that does not exist
		rospy.wait_for_service('/breadcrumb/request_path')
		self.srvc_bc = rospy.ServiceProxy('/breadcrumb/request_path', RequestPath)

		# Initialisation breadcrumb waypoints
		self.breadcrumbWPSnextIndex = 0
		self.breadcrumbMode = False
		self.breadcrumbWPS = []

		# Make some space to record down our current location
		self.current_location = Point()
		self.have_pose = False  # becomes True in callback_pose once we receive a pose

		# Set our linear and rotational velocities for the flight
		self.vel_linear = rospy.get_param("~vel_linear", 0.3)
		self.vel_yaw = rospy.get_param("~vel_yaw", 0.2)

		# Set our position and yaw waypoint accuracies
		self.accuracy_pos = rospy.get_param("~acc_pos", 0.1)
		self.accuracy_yaw = rospy.get_param("~acc_yaw", 0.1)

		# Loiter times (seconds)
		self.loiter_time  = rospy.get_param("~loiter_time", 5.0)   # how long to Loiter above ROI

		# Record dict of visited ROIs
		self.visited_rois = {}

		self.payloads_deployed = {"person": False, "bag": False}

		# Create an action client to talk to the flight controller
		# -----------------------------------------------------------------

		# Get the action topic name from a ROS parameter (~action_topic).
		# Default is 'spar/flight' if no parameter is set.
		action_ns = rospy.get_param("~action_topic", 'spar/flight')

		# Create a SimpleActionClient for the FlightMotionAction type.
		# This lets us send waypoints/goals to the flight server.
		self.spar_client = actionlib.SimpleActionClient(action_ns, FlightMotionAction)

		# Wait until the action server is online before continuing.
		# Prevents us from trying to send goals before the server is ready.
		rospy.loginfo("[INIT] Waiting for spar...")
		self.spar_client.wait_for_server()

		if not rospy.is_shutdown():
			# Good to go, start mission
			rospy.loginfo("[INIT] Starting waypoint mission")

			# Subscriptions first, so we already have pose during/after takeoff
			# Callback to save "current location" such that we can perform and return
			# from a diversion to the correct location
			# XXX: These topics could be hard-coded to avoid using a launch file
			self.sub_pose = rospy.Subscriber("/mavros/local_position/pose",
								 PoseStamped,
								 self.callback_pose)

			self.sub_battery = rospy.Subscriber(f"/mavros/battery", BatteryState, self.callback_battery_monitor)

			# --- Occupancy Grid (for snapping waypoints out of obstacles)
			self.grid = None
			self.grid_thresh = rospy.get_param("~obstacle_threshold",
											rospy.get_param("/breadcrumb/obstacle_threshold", 50))
			self.grid_inflation = rospy.get_param("~snap_inflation_margin", 0.0)  # meters; optional
			self.sub_grid = rospy.Subscriber("/grid", OccupancyGrid, self._cb_grid, queue_size=1)

			# Subscriber to catch "ROI" diversion commands
			# Critical targets
			self.sub_roi_person = rospy.Subscriber(f"/marker_locations/id/person", PointStamped, self.callback_inspect_roi, queue_size=1, callback_args=False)
			self.sub_roi_bag = rospy.Subscriber(f"/marker_locations/id/bag", PointStamped, self.callback_inspect_roi, queue_size=1, callback_args=False)
			self.sub_landing_marker = None

			# Other targets
			self.seen = set()
			self.other_marker_locations = {}
			self.sub_roi_marker = rospy.Subscriber("/marker_locations", Float32MultiArray, self.callback_record_marker, queue_size=10)

			# Create a ROS publisher to send messages to the '/payload/{PAYLOAD_TYPE}/set' topic.
			self.pub_epipen = rospy.Publisher("/payload/epipen/set", Bool, queue_size=10)
			self.pub_tracker = rospy.Publisher("/payload/tracker/set", Bool, queue_size=10)

			# Take off to a configured height; block until complete
			self.send_takeoff_motion()

			# Send first waypoint after takeoff
			self.send_wp(self.waypoints[0])
			self.waypoint_counter += 1

			# Setup a timer to check if our waypoint has completed at 20Hz
			self.timer = rospy.Timer( rospy.Duration(1.0/20.0), self.check_waypoint_status )

			# XXX: Could have a publisher to output our waypoint progress
			# throughout the flight (should publish each time the waypoint
			# counter is increased). Note: will also need to import "Float32"
			# from "std_msgs.msg" in the header
			# self.pub_progress = rospy.Subscriber("~waypoint_progress", Float32, 10)

			# Publisher to output our waypoint progress (as a float: 0.0–1.0)
			self.pub_progress = rospy.Publisher("~waypoint_progress", Float32, queue_size=10)

			# If shutdown is issued (eg. CTRL+C), cancel current
	 		# mission before rospy is shutdown.
			rospy.on_shutdown( lambda : self.shutdown() )

	# This function will check if a list of waypoints is in the format we expect
	def check_waypoints(self, wps):

		# Make sure waypoints are a list
		if not isinstance(wps, list):
			rospy.logwarn("[CHKWPS] Waypoints are not list")
			return False

		# Make sure we have at least one waypoint
		if len(wps) < 1:
			rospy.logwarn("[CHKWPS] Waypoints list is empty")
			return False

		# Check each of our waypoints
		for i in range(len(wps)):
			if not self.check_waypoint(wps[i]):
				rospy.logwarn("[CHKWPS] Waypoint %i did not pass check" % (i + 1))
				return False

		# If we haven't returned false yet, then waypoints look good!
		return True


	# This function will check if a waypoint is in the format we expect
	def check_waypoint(self, wp):
		# Make sure each waypoint is a list
		if not isinstance(wp, list):
			rospy.logwarn("[CHKWP] Waypoint is not a list of coordinates")
			return False
		# Make sure each waypoint has 4 values
		if len(wp) != 4:
			rospy.logwarn("[CHKWP] Waypoint has an invalid length (must be X/Y/Z/Yaw)")
			return False
		# Make sure waypoint is within mission zone
		x, y, z, yaw = wp
		if x > X_MAX or x < X_MIN:
			rospy.logwarn("[CHKWP] Waypoint x=%.2f outside [-4.0 4.0]" % x)
			return False
		if y > Y_MAX or y < Y_MIN:
			rospy.logwarn("[CHKWP] Waypoint y=%.2f outside [-3.2, 2.0]" % y)
			return False
		if z > Z_MAX or z < Z_MIN:
			rospy.logwarn("[CHKWP] Waypoint z=%.2f outside [0.5, 4.0]" % z)
			return False

		# If we haven't returned false yet, then waypoint looks valid!
		return True


	# This function will make sure we shut down the node as safely as possible
	def shutdown(self):
		self.pub_mission_status.publish("SHUTTING DOWN")
		# Unregister anything that needs it here
		self.sub_pose.unregister()
		if self.sub_landing_marker is not None:
			self.sub_landing_marker.unregister()
		if self.sub_roi_person is not None:
			self.sub_roi_person.unregister()
		if self.sub_roi_bag is not None:
			self.sub_roi_bag.unregister()
		self.spar_client.cancel_goal()

		rospy.loginfo("[SHUTDOWN] Autopilot stopped")
		self.pub_mission_status.publish("MISSION COMPLETE")
		sys.exit()

	def _run_breadcrumb_segment(self, start_xyz, end_xyz, yaw_for_segment):
		"""
		Runs a Breadcrumb plan from start_xyz -> end_xyz.
		start_xyz/end_xyz: (x, y, z)
		yaw_for_segment   : float (rad); we keep yaw constant along segment
		Returns True on success, False if planning/execution failed.
		"""
		try:
			# Snap endpoints to mission bounds
			s_start = self.snap_wp_in_mission([start_xyz[0], start_xyz[1], start_xyz[2], 0.0])
			s_end   = self.snap_wp_in_mission([end_xyz[0],   end_xyz[1],   end_xyz[2],   0.0])

			req = RequestPathRequest()
			req.start.x, req.start.y, req.start.z = s_start[0], s_start[1], s_start[2]
			req.end.x,   req.end.y,   req.end.z   = s_end[0],   s_end[1],   s_end[2]

			res = self.srvc_bc(req)
			breadcrumbWPS = []

			if len(res.path.poses) == 0:
				rospy.logwarn_throttle_identical(5, "[BC] No breadcrumb solution; falling back to direct.")
				return False
			
			# Loop through the solution returned from breadcrumb
			for i in range(len(res.path.poses)):
				rospy.loginfo("[BC]  [%0.2f;%0.2f;%0.2f]", res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z)
				breadcrumbWPS.append([res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z, 0.0])
				
			# Display the path
			self.breadcrumbWPS = breadcrumbWPS
			self.display_path(breadcrumbWPS,"/nav/pathBreadcrumb")

			for i, pose in enumerate(res.path.poses):
				wp = [pose.position.x, pose.position.y, pose.position.z, yaw_for_segment]
				self.send_wp(wp)
				self.spar_client.wait_for_result()
				if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
					rospy.logerr("[BC] Segment step %d failed; aborting breadcrumb execution.", i)
					return False

			return True

		except Exception as e:
			rospy.logerr("[BC] Exception while executing breadcrumb segment: %s", e)
			return False


	def callback_pose(self, msg_in: PoseStamped):
		# Position snapshot (for returns)
		self.current_location = msg_in.pose.position
		# Keep current yaw up to date
		self.current_yaw = self._quat_to_yaw(msg_in.pose.orientation)
		self.have_pose = True


	def callback_record_marker(self, msg_in: Float32MultiArray):
		data = msg_in.data or []
		if len(data) < 3:
			rospy.logwarn_throttle(5.0, "[MARKER] Float32MultiArray too short (<3)")
			return

		# record first-ever sighting per ID, ignore later updates
		for x, y, tid in self.iter_triples(data):
			if tid in self.seen or tid == self.LANDING_ARUCO_ID: # record landing ARUCO in visited_rois
				continue
			self.seen.add(tid)
			if tid not in self.other_marker_locations:
				self.other_marker_locations[tid] = {"x": x, "y": y, "z": 0.0}


	def iter_triples(self, data):
		n = len(data)
		for i in range(0, n - 2, 3):
			yield float(data[i]), float(data[i+1]), int(round(data[i+2]))


	# This function will fire whenever a ROI pose message is sent
	# It is also responsible for handling the ROI "inspection task"
	def callback_inspect_roi(self, msg_in: PointStamped, landing: bool = False):
		# Check we haven't visited this roi already
		hdr = getattr(msg_in, "_connection_header", {}) or {}
		topic = hdr.get("topic")  # may be None in some contexts

		# Extract the "id" from the topic (last part of the path)
		roi_id = topic.split("/")[-1]  # will be "person" or "bag"
		rospy.loginfo_throttle_identical(5, f"[ROI] ROI diversion triggered for id: {roi_id}")

		# Record our current location so we can return to it later
		start_x = float(self.current_location.x)
		start_y = float(self.current_location.y)
		start_z = float(self.current_location.z)
		# XXX:	It would also be a good idea to capture "current yaw" from
		#		the pose to maintain that throughout a diversion

		current_yaw = self.current_yaw

		# Set the "diversion waypoint" (at yaw zero)
		# editing from msg_in.pose.position.z to start_z
		# descend to 0.8 for payload deployment

		# Snap the diversion waypoint to be within the mission bounds.
		# Keeping z at mission altitud for now to ensure we can still
		# obtain a detection before descending
		raw_dwp = [msg_in.point.x, msg_in.point.y, start_z, current_yaw]
		dwp = self.snap_wp_in_mission(raw_dwp)
		if dwp[0] != raw_dwp[0] or dwp[1] != raw_dwp[1]:
			rospy.logwarn("ROI target snapped (%.2f, %.2f) -> (%.2f, %.2f)",
						raw_dwp[0], raw_dwp[1], dwp[0], dwp[1])

		if not self.check_waypoint(dwp):
			rospy.logwarn_throttle_identical(2, "[ROI] Bad ROI waypoint, outside of safe flight zone!\nCancelling diversion...")
			return

		# If we’re already diverting, ignore further ROI requests
		if self.performing_roi:
			rospy.logwarn_throttle_identical(2, "[ROI] ROI request ignored: diversion already in progress.")
			return

		# We need a current pose to be able to return safely
		if not self.have_pose:
			rospy.logwarn_throttle_identical(2, "[ROI] No current pose yet; cannot divert to ROI.")
			return

		if roi_id in self.visited_rois:
			if self.visited_rois[roi_id]["repositioning_status"] == "completed":
				rospy.loginfo_throttle_identical(2, "[ROI] Already visited ROI=%s, cancelling diversion...", roi_id)
				return

		# Set our flag that we are performing the diversion and cancel active goal
		self.performing_roi = True

		if not "repositioning_status" in self.visited_rois.get(roi_id, {}):
			rospy.loginfo_throttle_identical(5, "[ROI] Registering new ROI")
			# Set the "return waypoint" (at yaw zero)
			self.visited_rois[roi_id] = {"rwp": [start_x, start_y, start_z, current_yaw], "repositioning_status": "required"}

			rospy.loginfo("[ROI] Starting diversion to ROI...")
			self.pub_mission_status.publish("DIVERTING")
		else:
			rospy.loginfo_throttle_identical(5, "[ROI] Repositioning above ROI...")
			self.visited_rois[roi_id]["repositioning_status"] = "repositioning"
			self.pub_mission_status.publish("REPOSITIONING")
			dwp[2] = 0.8 # descend to 0.8m for repositioning

		self.spar_client.cancel_goal()

		# XXX: Could pause here for a moment with ( "rospy.sleep(...)" ) to make sure the UAV stops correctly

		rospy.sleep(rospy.Duration(0.5))

		# Try obstacle-aware path to ROI
		start_xyz = (float(self.current_location.x), float(self.current_location.y), float(self.current_location.z))
		end_xyz   = (dwp[0], dwp[1], dwp[2])

		if not self._run_breadcrumb_segment(start_xyz, end_xyz, current_yaw):
			# Fallback: direct leg if Breadcrumb couldn't solve
			self.send_wp(dwp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				rospy.logwarn_throttle_identical(2, "[ROI] Could not reach RWP from ROI; cancelling diversion.")
				try:
					self.spar_client.cancel_goal()
				except Exception as e:
					rospy.logwarn_throttle_identical(2, f"[ROI] Spar Client Cancel Goal error: {e}")

				self.performing_roi = False
				return

		rospy.loginfo("[ROI] Reached diversion ROI!")

		# Repositioning logic
		if self.visited_rois[roi_id]["repositioning_status"] == "required":
			# Allow callback to be retriggered and divert to more updated ROI position
			self.performing_roi = False
			return
		elif self.visited_rois[roi_id]["repositioning_status"] == "repositioning":
			# Repositioning complete
			self.visited_rois[roi_id]["repositioning_status"] = "completed"
			self.visited_rois[roi_id]["position"] = dwp

		# Loiter above ROI
		if self.loiter_time > 0.0:
			self.pub_mission_status.publish("STABILISING")
			rospy.loginfo("[ROI] Hovering over ROI for %.1f s", self.loiter_time)
			rospy.sleep(rospy.Duration(self.loiter_time))

		# !!!: Change this to modify behaviour at ROIs
		if not landing: # deployment roi
			if roi_id == "person":
				self.pub_mission_status.publish("DEPLOYING EPIPEN")
				rospy.loginfo("[ROI] Hovering over person...")
				rospy.loginfo("[ROI] Deploying epipen payload...")
				self.pub_epipen.publish(Bool(True))
				self.payloads_deployed["person"] = True
				rospy.loginfo("[ROI] Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			elif roi_id == "bag":
				self.pub_mission_status.publish("DEPLOYING TRACKER")
				rospy.loginfo("[ROI] Hovering over bag...")
				rospy.loginfo("[ROI] Deploying tracker payload...")
				self.pub_tracker.publish(Bool(True))
				self.payloads_deployed["bag"] = True
				rospy.loginfo("[ROI] Hovering for 2 seconds...")
				rospy.sleep(rospy.Duration(2))
			else:
				rospy.loginfo("[ROI] Hovering over ROI...")
				rospy.sleep(rospy.Duration(self.loiter_time))

		# Land if landing flag true
		if landing:
			# Land at ROI
			rospy.loginfo("[ROI] Setting down at ROI")
			try:
				self.land()
			except e:
				rospy.signal_shutdown(f"roi_land_failed: {e}")
				self.performing_roi = False
				return

		rospy.loginfo("[ROI] Returning to pre-diversion position...")
		self.pub_mission_status.publish("RETURNING")
		rwp = self.visited_rois[roi_id]["rwp"]
		start_xyz = (float(self.current_location.x), float(self.current_location.y), float(self.current_location.z))
		end_xyz   = (rwp[0], rwp[1], rwp[2])

		if not self._run_breadcrumb_segment(start_xyz, end_xyz, current_yaw):
			# Fallback: direct leg
			self.send_wp(rwp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				rospy.logwarn_throttle_identical(2, "[ROI] Could not reach RWP from ROI; cancelling diversion.")
				try:
					self.spar_client.cancel_goal()
				except Exception as e:
					rospy.logwarn_throttle_identical(2, f"[ROI] Spar Client Cancel Goal error: {e}")

				self.performing_roi = False
				return

		# "waypoint_counter" represents the "next waypoint"
		# "waypoint_counter - 1" represents the "current waypoint"
		rospy.loginfo("[ROI] Resuming flight plan from waypoint %i!" % (self.waypoint_counter - 1))
		self.send_wp(self.waypoints[self.waypoint_counter - 1])
		# Unset our flag that we are performing a diversion
		# to allow the waypoint timer to take back over
		self.performing_roi = False


	def callback_battery_monitor(self, msg_in: BatteryState):
		try:
			pct = float(msg_in.percentage)
			if pct > 0 and pct < 0.20 and not self.performing_emergency and not self.landed: # when battery drops below under 20%
				rospy.logwarn_throttle_identical(5, f"[BATT] Critical Low Battery: {pct*100:.1f}%")

				if not self.performing_roi:
					rospy.logwarn_throttle_identical(5, f"[BATT] Commencing emergency landing...")

					# Stop any ROI diversion, cancel guidance, and land safely
					try:
						self.spar_client.cancel_goal()
						rospy.sleep(rospy.Duration(0.5))
					except Exception as e:
						rospy.logwarn_throttle_identical(5, f"[BATT] Spar Client Cancel Goal error: {e}")

					self.performing_roi = False
					self.performing_emergency = True

					self.pub_mission_status.publish("LOW BATTERY")
					# Attempt emergency landing (try ARUCO latch, else fallback to launch)
					self.emergency_land()
				else:
					rospy.logwarn_throttle_identical(5, f"[BATT] Waiting for ROI diversion to finish...")

		except Exception as e:
			rospy.logwarn_throttle_identical(5, f"[BATT] Battery percentage read error: {e}")
			return

	def emergency_land(self):
		"""Emergency landing sequence:
		1) Try to get latched landing ARUCO quickly.
		2) Else land at predefined safe point.
		"""
		if not self.have_pose:
			rospy.logwarn_throttle_identical(3, "[EMERG] No current pose; attempting straight LAND.")
			try:
				rospy.loginfo("[EMERG] Emergency LAND command issued without pose.")
				self.land()
			except Exception as e:
				rospy.logerr(f"[EMERG] Emergency LAND failed: {e}")
			return

		wait_timeout = 3.0 # seconds to wait for latched ARUCO
		current_yaw = self.current_yaw

		# Try to acquire latched landing ARUCO quickly
		topic = f"/marker_locations/id/{self.LANDING_ARUCO_ID}"
		rospy.loginfo(f"[EMERG] Waiting up to {wait_timeout:.1f}s for latched ARUCO on {topic}...")
		aruco_pt = None
		try:
			# If the topic is latched and was published before, this returns immediately.
			msg_in = rospy.wait_for_message(topic, PointStamped, timeout=wait_timeout)
			aruco_pt = [msg_in.point.x, msg_in.point.y, 0.8, current_yaw]
			rospy.loginfo("[EMERG] Latched ARUCO acquired.")
		except Exception:
			rospy.logwarn("[EMERG] No ARUCO available; falling back to predefined safe landing point.")

		# Choose target - LANDING marker if found, else fallback point (takeoff location)
		if aruco_pt is not None:
			target = aruco_pt
		else:
			target = [-1.0, -1.0, 0.8, current_yaw]

		twp = self.snap_wp_in_mission(target)

		if not self.check_waypoint(twp):
			rospy.logerr("[EMERG] Landing waypoint is outside safe flight zone. Issuing direct LAND.")
			try:
				self.land()
			except Exception as e:
				rospy.logerr(f"[EMERG] Direct LAND failed: {e}")
			return

		# Cancel any active goal and fly to approach altitude
		rospy.sleep(rospy.Duration(0.5))  # brief pause to let controller settle
		rospy.loginfo("[EMERG] Navigating to emergency landing approach point...")
		
		# Move toward the landing target with obstacle-aware path if possible
		start_xyz = (float(self.current_location.x), float(self.current_location.y), float(self.current_location.z))
		end_xyz   = (twp[0], twp[1], twp[2])

		ok = self._run_breadcrumb_segment(start_xyz, end_xyz, self.current_yaw)
		if not ok:
			rospy.logwarn("[EMERG] Breadcrumb failed; attempting direct leg to landing point.")
			self.send_wp(twp)
			self.spar_client.wait_for_result()
			if self.spar_client.get_state() != GoalStatus.SUCCEEDED:
				rospy.logerr("[EMERG] Could not reach landing point; issuing immediate LAND here.")
				try:
					self.land()
				except Exception as e:
					rospy.logerr(f"[EMERG] Direct LAND failed: {e}")
					return

		# Stabilize
		if self.loiter_time > 0.0:
			rospy.loginfo(f"[EMERG] Stabilizing over landing point for {self.loiter_time:.1f}s...")
			rospy.sleep(rospy.Duration(self.loiter_time))

		rospy.loginfo("[EMERG] Initiating final landing...")
		try:
			self.land()
			rospy.loginfo("[EMERG] Landing complete.")
		except Exception as e:
			rospy.logerr(f"[EMERG] Landing command failed: {e}")
		return

	def land(self):
		self.pub_mission_status.publish("LANDING")
		if self.send_land_motion():
			rospy.loginfo("ROI landing complete; shutting down.")

			try:
				rospy.loginfo("CRITICAL ROI:")
				rospy.loginfo(json.dumps(self.visited_rois, indent=4))
				rospy.loginfo("NON-CRITICAL ROI:")
				rospy.loginfo(json.dumps(self.other_marker_locations, indent=4))
			except Exception as e:
				rospy.logerr(f"[LAND] No data recorded: {e}")

			try:
				stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
				outdir = os.path.join(os.getcwd(), "catkin_ws")
				os.makedirs(outdir, exist_ok=True)
				path = os.path.join(outdir, f"flight_{stamp}_rois.json")

				summary = {
					"flight_timestamp": stamp,
					"critical_roi": self.visited_rois,
					"non_critical_roi": self.other_marker_locations
				}
				with open(path, "w") as f:
					json.dump(summary, f, indent=4, sort_keys=True)

				rospy.loginfo(f"[LAND] Saved ROI summary to: {path}")

			except Exception as e:
				rospy.logerr(f"[LAND] Failed to save ROI summary: {e}")
			
			self.landed = True
			rospy.signal_shutdown("complete")
		else:
			rospy.logerr("[LAND] LANDING FAILED")


	# This function is for convinience to simply send out a new waypoint
	def send_wp(self, wp):
		# Make sure the waypoint is valid before continuing
		if not self.check_waypoint(wp):
			raise ValueError("Invalid waypoint input!")

		## Build the flight goal
		# -----------------------
		# Construct an empty goal message of type spar_msgs/FlightMotionGoal.
		goal = FlightMotionGoal()
		# Select motion mode: 'go to' a pose (as opposed to takeoff/land/velocity).
		goal.motion = FlightMotionGoal.MOTION_GOTO

		# Target position in SPAR's local frame.
		goal.position.x = wp[0]
		goal.position.y = wp[1]
		goal.position.z = wp[2]
		# Target yaw (radians). Convention: typically yaw=0 aligns with +X axis of the local frame.
		goal.yaw = wp[3]

		# Commanded limits: vertical climb/descend speed, horizontal speed, and yaw rate.
		goal.velocity_vertical = self.vel_linear
		goal.velocity_horizontal = self.vel_linear
		goal.yawrate = self.vel_yaw

		# Tell SPAR to only declare success when we are within the acceptance thresholds below.
		goal.wait_for_convergence = True

		# Acceptance thresholds:
		# - position_radius (meters): how close to (x,y,z) we must be.
		# - yaw_range (radians): how close to target yaw we must be.
		goal.position_radius = self.accuracy_pos
		goal.yaw_range = self.accuracy_yaw

		# For this function, we don't wait in the loop.
		# Instead we just send the waypoint and check up on it later
		# This checking is either with the "self.timer" for waypoints
		# or with direct calls during the ROI diversion
		self.spar_client.send_goal(goal)
		 # If shutdown is issued, cancel current mission before rospy is shutdown
		rospy.on_shutdown(lambda : self.spar_client.cancel_goal())

	def send_takeoff_motion(self):
		"""
		Command a vertical takeoff using SPAR's FlightMotionAction.
		Blocks until the server reports success/failure.
		"""
		self.pub_mission_status.publish("TAKEOFF")
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_TAKEOFF

		# Parameters (private to this node). Change names if you prefer.
		height = rospy.get_param("~height", 1.0)           # meters
		speed  = rospy.get_param("~speed",  0.2)           # m/s ascent speed

		goal.position.z = height
		goal.velocity_vertical = speed

		# Convergence rules (reuse your existing tolerances if you like)
		goal.wait_for_convergence = True
		goal.position_radius = rospy.get_param("~position_radius", 0.1)  # m
		goal.yaw_range       = rospy.get_param("~yaw_range",       0.1)  # rad

		rospy.loginfo("[TKOFF] Takeoff: target z=%.2f m, vz=%.2f m/s", height, speed)
		self.spar_client.send_goal(goal)

		# Cancel safely if the node is stopped mid-takeoff
		rospy.on_shutdown(self.spar_client.cancel_goal)

		self.spar_client.wait_for_result()
		st = self.spar_client.get_state()

		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("[TKOFF] Takeoff complete.")
		else:
			# Mirror your existing status handling
			rospy.logerr("[TKOFF] Takeoff failed (state=%d). Aborting mission.", st)
			rospy.signal_shutdown("takeoff_failed")

	def send_land_motion(self, speed=None):
		"""
		Land using SPAR's FlightMotionAction (MOTION_LAND).
		Returns True on success, False otherwise.
		"""
		goal = FlightMotionGoal()
		goal.motion = FlightMotionGoal.MOTION_LAND

		# Use ~land_speed if provided, else fall back to ~speed (or 0.2)
		if speed is None:
			speed = rospy.get_param("~land_speed", rospy.get_param("~speed", 0.2))
		goal.velocity_vertical = float(speed)  # SPAR ignores other velocities for land

		rospy.loginfo("[LAND] Landing...")
		self.spar_client.send_goal(goal)
		rospy.on_shutdown(self.spar_client.cancel_goal)
		self.spar_client.wait_for_result()

		st = self.spar_client.get_state()
		if st == GoalStatus.SUCCEEDED:
			rospy.loginfo("[LAND] Landing complete!")
			return True

		# Detailed feedback (optional)
		rospy.logerr("[LAND] Landing failed (state=%d).", st)
		if st in (GoalStatus.PENDING, GoalStatus.ACTIVE):
			rospy.loginfo("[LAND] Sent command to cancel current mission")
		elif st == GoalStatus.PREEMPTED:
			rospy.logwarn("[LAND] The current mission was cancelled")
		elif st == GoalStatus.ABORTED:
			rospy.logwarn("[LAND] The current mission was aborted")
		elif st == GoalStatus.RECALLED:
			rospy.logerr("[LAND] Error: The current mission was recalled")
		elif st == GoalStatus.REJECTED:
			rospy.logerr("[LAND] Error: The current mission was rejected")
		else:
			rospy.logerr("[LAND] Error: Unknown goal status")
		return False

	# This function will fire whenever we recieve a timer event (te) from rospy.Timer()
	# The main purpose is to check if a waypoint has been reached,
	# and if so, send out the next waypoint to continue the mission
	def check_waypoint_status(self, te):
		# If we're performing the ROI diversion, then don't do
		# anything here, as this is handled in that function
		if not self.performing_roi and not self.performing_emergency and not self.landed:
			# If the last segment has succeeded.
			# For more complex tasks, it might be necessary to also
			# check if you are in waypoint or diversion mode here.
			# Hint: really, we should check for other status states
			#		(such as aborted), as there are some states
			#		where we won't recover from, and should just exit
			if self.spar_client.get_state() == GoalStatus.SUCCEEDED:
				rospy.loginfo_throttle_identical(5, "[WPSTAT] Reached waypoint %i!" % (self.waypoint_counter))

				# XXX:	Another check could go here to finish the mission early
				#		if "all" inspection tasks have been completed
				#		(Add in another "if" and make the waypoint counter check
				#		 an "elif" check instead.
				#		 i.e. if complete; elif more wps; else wps finished)
				if self.waypoint_counter < (len(self.waypoints)):
					self.pub_mission_status.publish("SEARCHING")

					if not self.breadcrumbMode:

						sx, sy, sz = self.waypoints[self.waypoint_counter - 1][0:3]
						ex, ey, ez = self.waypoints[self.waypoint_counter][0:3]

						# Snap both endpoints; keep original z (already in mission plan), clamped by helper.
						s_start = self.snap_wp_in_mission([sx, sy, sz, 0.0])
						s_end   = self.snap_wp_in_mission([ex, ey, ez, 0.0])

						if (s_start[0], s_start[1]) != (sx, sy):
							rospy.logwarn("[WPSTAT] Segment start snapped (%.2f, %.2f) -> (%.2f, %.2f)", sx, sy, s_start[0], s_start[1])
						if (s_end[0], s_end[1]) != (ex, ey):
							rospy.logwarn("[WPSTAT] Segment end snapped (%.2f, %.2f) -> (%.2f, %.2f)", ex, ey, s_end[0], s_end[1])

						req = RequestPathRequest()
						req.start.x, req.start.y, req.start.z = s_start[0], s_start[1], s_start[2]
						req.end.x,   req.end.y,   req.end.z   = s_end[0],   s_end[1],   s_end[2]
						
						res = self.srvc_bc(req)
						
						# Breadcrumb will return a vector of poses if a solution was found
						# If no solution was found (i.e. no solution, or request bad # start/end), then breadcrumb returns and empty vector
						# # XXX: You could also use res.path_sparse (see breadcrumb docs)
						breadcrumbWPS = []
						
						if len(res.path.poses) > 0:
							# Print the path to the screen
							rospy.loginfo("[WPSTAT] Segment {} to {}:".format(self.waypoint_counter - 1,self.waypoint_counter))
							rospy.loginfo("[WPSTAT] [%0.2f;%0.2f;%0.2f] => [%0.2f;%0.2f;%0.2f]", req.start.x,req.start.y,req.start.z, req.end.x,req.end.y,req.end.z)
							
							# Loop through the solution returned from breadcrumb
							for i in range(len(res.path.poses)):
								rospy.loginfo("[WPSTAT]  [%0.2f;%0.2f;%0.2f]", res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z)
								breadcrumbWPS.append([res.path.poses[i].position.x, res.path.poses[i].position.y, res.path.poses[i].position.z, 0.0])
								
							# Display the path
							# print(breadcrumbWPS)
							self.breadcrumbWPS = breadcrumbWPS
							self.display_path(breadcrumbWPS,"/nav/pathBreadcrumb")
							self.breadcrumbMode = True
							self.breadcrumbWPSnextIndex = 0
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							self.breadcrumbWPSnextIndex +=1
						else:
							rospy.logerr_throttle_identical(5, "[WPSTAT] breadcrumb solution not found, falling back to original path")
							self.send_wp(self.waypoints[self.waypoint_counter])
							self.waypoint_counter += 1

					else:
						if self.breadcrumbWPSnextIndex < (len(self.breadcrumbWPS)):
							# We got here a breadcrumb path, we should exuted down here:
							self.send_wp(self.breadcrumbWPS[self.breadcrumbWPSnextIndex])
							
							# Increment our waypoint counte
							self.breadcrumbWPSnextIndex +=1
						else:
							# Calculate fraction of mission complete (waypoints done / total)
							progress = float(self.waypoint_counter) / float(len(self.waypoints))
							self.pub_progress.publish(progress)
							rospy.loginfo("[WPSTAT] Mission progress: %.0f%%" % (progress * 100.0))
							
							# If we finish with the breadcrumb waypoints we increase normal waypoints
							self.waypoint_counter += 1
							self.breadcrumbMode = False

				else:
					# Else the mission is over, shutdown and quit the node
					# XXX:	This could be used to restart the mission back to the
					#		first waypoint instead to restart the mission
					rospy.loginfo_throttle_identical(5, "[WPSTAT] Search complete! Checking payloads deployed...")
					self.pub_mission_status.publish("SEARCH COMPLETE")

					if self.payloads_deployed["person"] == False:
						self.pub_mission_status.publish("DEPLOYING EPIPEN")
						rospy.loginfo("[WPSTAT] Deploying epipen payload...")
						self.pub_epipen.publish(Bool(True))
						self.payloads_deployed["person"] = True
						rospy.loginfo("[WPSTAT] Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))

					if self.payloads_deployed["bag"] == False:
						self.pub_mission_status.publish("DEPLOYING TRACKER")
						rospy.loginfo("[WPSTAT] Deploying tracker payload...")
						self.pub_tracker.publish(Bool(True))
						self.payloads_deployed["bag"] = True
						rospy.loginfo("[WPSTAT] Hovering for 2 seconds...")
						rospy.sleep(rospy.Duration(2))

					rospy.loginfo_throttle_identical(5, "[WPSTAT] Attempting landing...")
					self.sub_landing_marker = rospy.Subscriber(f"/marker_locations/id/{self.LANDING_ARUCO_ID}", PointStamped, self.callback_inspect_roi, queue_size=1, callback_args=True)

			elif (self.spar_client.get_state() == GoalStatus.PREEMPTED) or (self.spar_client.get_state() == GoalStatus.ABORTED) or (self.spar_client.get_state() == GoalStatus.REJECTED):
				self.pub_mission_status.publish("CANCELLED")
				rospy.loginfo("[WPSTAT] Mission cancelled!")
				rospy.signal_shutdown("cancelled")

	def _clamp(self, v, vmin, vmax):
		return max(vmin, min(v, vmax))

	def _in_xy_bounds(self, x, y):
		return (X_MIN <= x <= X_MAX) and (Y_MIN <= y <= Y_MAX)

	def _cb_grid(self, msg):
		self.grid = msg

	def _world_to_cell(self, x, y):
		if self.grid is None:
			return None
		res = self.grid.info.resolution
		org = self.grid.info.origin.position
		ix = int((x - org.x) / res)
		iy = int((y - org.y) / res)
		if ix < 0 or iy < 0 or ix >= self.grid.info.width or iy >= self.grid.info.height:
			return None
		return ix, iy

	def _cell_value(self, ix, iy):
		if self.grid is None: 
			return 100
		idx = iy * self.grid.info.width + ix
		data = self.grid.data
		if idx < 0 or idx >= len(data):
			return 100
		v = data[idx]
		return 100 if v < 0 else v

	def _is_free(self, x, y):
		if not self._in_xy_bounds(x, y):
			return False
		c = self._world_to_cell(x, y)
		if c is None:
			return False
		ix, iy = c
		return self._cell_value(ix, iy) < self.grid_thresh

	def _snap_to_free_bounded(self, x, y, max_radius=1.5, angular_samples=24):
		"""
		Snap (x,y) to nearest free cell respecting mission bounds.
		If already free, returns unchanged. If no free cell found within radius,
		returns (x,y) clamped to mission box (still may be occupied).
		"""
		# First clamp to mission bounds so we don't search outside
		x = self._clamp(x, X_MIN, X_MAX)
		y = self._clamp(y, Y_MIN, Y_MAX)

		if self._is_free(x, y):
			return x, y

		if self.grid is None:
			# No grid yet – at least return bounded coords
			return x, y

		res = self.grid.info.resolution
		r = res
		while r <= max_radius:
			for k in range(angular_samples):
				th = (2.0 * pi * k) / float(angular_samples)
				xt = self._clamp(x + r * cos(th), X_MIN, X_MAX)
				yt = self._clamp(y + r * sin(th), Y_MIN, Y_MAX)
				if self._is_free(xt, yt):
					return xt, yt
			r += res

		# Nothing found: fall back to bounded original
		return x, y

	def snap_wp_in_mission(self, wp, max_radius=1.5):
		"""
		Given [x,y,z,yaw], snap x,y out of obstacles & clamp z so the result
		*passes check_waypoint()*.
		"""
		x, y, z, yaw = wp
		# snap x,y to free within bounds
		sx, sy = self._snap_to_free_bounded(x, y, max_radius=max_radius)

		# clamp z strictly to mission vertical bounds
		sz = self._clamp(z, Z_MIN, Z_MAX)

		snapped = [sx, sy, sz, yaw]

		# As a safety net: if something still fails (e.g., grid unknown),
		# try shrinking the radius a bit to find any valid point.
		if not self.check_waypoint(snapped):
			rr = max_radius
			while rr > 0.0:
				sx, sy = self._snap_to_free_bounded(x, y, max_radius=rr)
				snapped = [sx, sy, sz, yaw]
				if self.check_waypoint(snapped):
					break
				rr -= 0.25
		return snapped

	# Display a path
	def display_path(self, wps, name):
		rospy.loginfo("[DISP] Displaying path...")
		pub_path = rospy.Publisher(name, Path, queue_size=10, latch=True)
		msg = Path()
		msg.header.frame_id = "/map"
		msg.header.stamp = rospy.Time.now()
	
		for wp in wps:
			pose = PoseStamped()
			pose.pose.position.x = wp[0]
			pose.pose.position.y = wp[1]
			pose.pose.position.z = wp[2]
	
			pose.pose.orientation.w = 1.0
			pose.pose.orientation.x = 0.0
			pose.pose.orientation.y = 0.0
			pose.pose.orientation.z = 0.0
	
			msg.poses.append(pose)
		rospy.loginfo("[DISP] Publishing path...")
		pub_path.publish(msg)

	def _quat_to_yaw(self, q):
		"""Return yaw (rad) from geometry_msgs/Quaternion."""
		_, _, yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])
		return yaw

# ===================== Planner (X up, Y left) =====================

def path_planner_xyleft(
	Xmin=-3.95, Xmax=3.95,     # vertical extent (up/down)
	Ymin=-3.15, Ymax= 1.95,    # horizontal extent (right/left)
	startXY=(-1.0, -1.0),    # (X, Y) at ground
	altitude=3.0,
	fov_x_deg=54.0,          # across-track FOV (affects row spacing)
	fov_y_deg=None,          # along-track FOV (image width). If None, equals fov_x_deg
	overlap_across=0.30,     # across-track overlap between rows
	yaw=0.0,
	takeoff_alt=1.0,
	ensure_cover=True,
	n_midpoints = 3,
	start_side="right",      # "right" = start at (Xmin, Ymin), first row right->left
):
	"""
	World frame:
	  +X up, +Y left. Waypoints returned as [X, Y, Z, yaw].

	Returns:
	  waypoints: (N,4)
	  X_rows:    1D array of row X positions (bottom->top)
	  frame_X:   ground footprint size along X (meters)
	  frame_Y:   ground footprint size along Y (meters)
	  survey_indices: indices of survey-only points in the waypoint list
	"""
	if fov_y_deg is None:
		fov_y_deg = fov_x_deg

	# Ground image footprint (FULL FOVs)
	frame_X = 2.0 * altitude * np.tan(np.deg2rad(0.5 * fov_x_deg))  # along +X
	frame_Y = 2.0 * altitude * np.tan(np.deg2rad(0.5 * fov_y_deg))  # along +Y

	# Row spacing from overlap
	overlap_across = float(np.clip(overlap_across, 0.0, 0.99))
	dX = max(frame_X * (1.0 - overlap_across), 1e-6)

	# # Build rows in X (bottom -> top)
	# X_rows = [Xmin]
	# while X_rows[-1] + dX < Xmax:
	#     X_rows.append(X_rows[-1] + dX)
	# if ensure_cover and X_rows[-1] < Xmax:
	#     X_rows.append(Xmax)
	# X_rows = np.asarray(X_rows, float)

	# Build rows in X (bottom -> top) with even spacing that honors endpoints
	# Previous behavior walked by dX and then optionally forced Xmax,
	# which could create two rows very close together at the top.
	# We instead choose the number of intervals so spacing <= dX and include Xmin/Xmax.
	span = (Xmax - Xmin)
	if span <= 0:
		X_rows = np.asarray([Xmin], float)
	else:
		# number of intervals so that spacing <= dX (never bigger than requested)
		n_intervals = max(1, int(np.ceil(span / dX)))
		X_rows = np.linspace(Xmin, Xmax, n_intervals + 1, dtype=float)

	# First row direction: start at bottom-right if start_side == "right"
	first_right_to_left = (start_side.lower() == "right")

	# Survey points: alternating sweeps along Y
	survey_pts = []
	for i, X in enumerate(X_rows):
		rtl = first_right_to_left if (i % 2 == 0) else (not first_right_to_left)
		if rtl:
			a = [X, Ymin, altitude, yaw]  # right
			b = [X, Ymax, altitude, yaw]  # left
		else:
			a = [X, Ymax, altitude, yaw]  # left
			b = [X, Ymin, altitude, yaw]  # right

		row_pts = [a]
		if n_midpoints > 0:
			for k in range(1, n_midpoints+1):
				frac = k / (n_midpoints + 1)
				mY = a[1] + frac * (b[1] - a[1])
				row_pts.append([X, mY, altitude, yaw])
		row_pts.append(b)

		survey_pts += row_pts
	survey_pts = np.asarray(survey_pts, float)

	# Stitch with staging/return
	Sx, Sy = startXY
	waypoints = []
	waypoints.append([Sx, Sy, takeoff_alt, 0.0])  # (-1,-1,1,0)
	waypoints.append([Sx, Sy, altitude,    0.0])  # (-1,-1,alt,0)

	# ! Was causing a duplicate
	# if survey_pts.size:
	# 	fx, fy = survey_pts[0, 0], survey_pts[0, 1]
	# 	if abs(fx - Sx) > 1e-9 or abs(fy - Sy) > 1e-9:
	# 		waypoints.append([fx, fy, altitude, yaw])

	survey_start_idx = len(waypoints)
	waypoints.extend(survey_pts.tolist())
	survey_end_idx = len(waypoints)

	waypoints = np.asarray(waypoints, float)

	return waypoints

def main(args):
	# Initialise ROS
	rospy.init_node('autopilot')
	pub_mission_status = rospy.Publisher("/mission/status", String, queue_size=10)

	# Load config
	print(os.getcwd())
	with open(f"{os.getcwd()}/catkin_ws/config.yaml", "r") as f:
		config = yaml.safe_load(f)

	# Set our altitude from config
	ALTITUDE = config["altitude"]

	# List of waypoints
	# [X, Y, Z, Yaw]
	pub_mission_status.publish("PLANNING FLIGHT PATH")
	wps = path_planner_xyleft(
			Xmin=X_MIN + 0.1, Xmax=X_MAX - 0.1,
			Ymin=Y_MIN + 0.1, Ymax=Y_MAX - 0.1,
			startXY=(-1.0, -1.0),
			altitude=ALTITUDE,
			fov_x_deg=54.0,
			fov_y_deg=54.0,
			overlap_across=0.30,
			yaw=0.0,
			n_midpoints=3,
			start_side="right"   # start at bottom-right
		)
	waypoints_list = [[round(val, 2) for val in row] for row in wps.tolist()]

	# wps = [
	# 		[-1.00, -1.00, 1.00, 0.00],
	# 		[-1.00, -1.00, ALTITUDE, 0.00],
	# 		[-3.70, -2.40, ALTITUDE, 0.00],
	# 		[-3.70, -0.25, ALTITUDE, 0.00],
	# 		[-3.70,  1.90, ALTITUDE, 0.00],
	# 		[-1.56,  1.90, ALTITUDE, 0.00],
	# 		[-1.56, -0.25, ALTITUDE, 0.00],
	# 		[-1.56, -2.40, ALTITUDE, 0.00],
	# 		[ 0.58, -2.40, ALTITUDE, 0.00],
	# 		[ 0.58, -0.25, ALTITUDE, 0.00],
	# 		[ 0.58,  1.90, ALTITUDE, 0.00],
	# 		[ 2.72,  1.90, ALTITUDE, 0.00],
	# 		[ 2.72, -0.25, ALTITUDE, 0.00],
	# 		[ 2.72, -2.40, ALTITUDE, 0.00],
	# 		[ 3.70, -2.40, ALTITUDE, 0.00],
	# 		[ 3.70, -0.25, ALTITUDE, 0.00],
	# 		[ 3.70,  1.90, ALTITUDE, 0.00]
	# 	]

	# Create our Autopilot class option
	pilot = autopilot(waypoints_list, config, pub_mission_status)

	# rospy.spin() keeps the program running once setup is done.
	# Without it, the script would exit immediately after starting.
	# It lets ROS continuously process incoming messages and call
	# subscriber callbacks (e.g. for pose updates or ROI triggers).
	rospy.spin()


if __name__ == '__main__':
	try:
		main(sys.argv)
	except rospy.ROSInterruptException:
		pass

	print('')
